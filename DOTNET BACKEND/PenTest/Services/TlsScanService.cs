using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using Microsoft.EntityFrameworkCore;
using PenTest.Interfaces;
using Repository;
using Repository.Entities;

namespace PenTest.Services;

public class TlsScanService(PgContext context) : ITlsScanService
{
    private const string AutoCheckName = "TLS";
    
    private StringBuilder _logs = new();
    
    public async Task<AutomaticCheckAuditRow> Scan(string domainNoPrefix)
    {
        var automaticCheck = await context.AutomaticChecks
            .Where(c => c.Name == AutoCheckName)
            .FirstAsync();

        var domain = "https://" + domainNoPrefix;

        try
        {
            // DNS Resolution
            var ipAddresses = await Dns.GetHostAddressesAsync(domainNoPrefix);
            var ip = ipAddresses[0]; // Use first resolved IP
            
            _logs.AppendLine($"Resolved {domain} to {ip}");

            // TCP and SSL Connection
            using var client = new TcpClient();
            await client.ConnectAsync(ip, 443);

            using var sslStream = new SslStream(
                client.GetStream(),
                false,
                new RemoteCertificateValidationCallback(ValidateCertificate),
                null
            );

            await sslStream.AuthenticateAsClientAsync(domain); // Important: use domain here, not IP

            var cert = new X509Certificate2(sslStream.RemoteCertificate);
            _logs.AppendLine("\n=== Certificate Info ===");
            _logs.AppendLine($"Subject: {cert.Subject}");
            _logs.AppendLine($"Issuer: {cert.Issuer}");
            _logs.AppendLine($"Valid From: {cert.NotBefore}");
            _logs.AppendLine($"Valid Until: {cert.NotAfter}");
            _logs.AppendLine($"Thumbprint: {cert.Thumbprint}");

            // Optional: Revocation check
            _logs.AppendLine("\n=== Revocation Check ===");
            var chain = new X509Chain();
            chain.ChainPolicy.RevocationMode = X509RevocationMode.Online;
            chain.ChainPolicy.RevocationFlag = X509RevocationFlag.EntireChain;

            bool isValid = chain.Build(cert);
            if (!isValid)
            {
                _logs.AppendLine("Certificate validation failed:");
                foreach (var status in chain.ChainStatus)
                {
                    _logs.AppendLine($" - {status.StatusInformation.Trim()}");
                }
                return new AutomaticCheckAuditRow
                {
                    AutomaticCheck = automaticCheck,
                    Passed = false,
                    Comment = _logs.ToString()
                };
            }
            else
            {
                return new AutomaticCheckAuditRow
                {
                    AutomaticCheck = automaticCheck,
                    Passed = true,
                    Comment = _logs.ToString()
                };                
                // _logs.AppendLine("Certificate is valid and not revoked.");
            }
        }
        catch (Exception ex)
        {
            return new AutomaticCheckAuditRow
            {
                AutomaticCheck = automaticCheck,
                Passed = true,
                Comment = $"Could not analyze domain {domain}, make sure it is not just an ip address"
            };        
        }
    }

    private static bool ValidateCertificate(
        object sender, 
        X509Certificate certificate, 
        X509Chain chain, 
        SslPolicyErrors sslPolicyErrors)
    {
        if (sslPolicyErrors == SslPolicyErrors.None)
            return true;

        // _logs.AppendLine("\nSSL Policy Errors:");
        // _logs.AppendLine(sslPolicyErrors.ToString());
        return false;
    }
}